---
title: Securing incoming traffic in Cloud Foundry
owner: CF for VMs Networking
---

<%# Reset page title based on platform type %>
<% if vars.platform_code != 'CF' %>

<% set_title("Securing incoming traffic in", vars.app_runtime_abbr) %>

<% end %>

You can secure HTTP traffic into your <%= vars.app_runtime_abbr %> deployment with TLS certificates. You can also configure the location
where your deployment stops TLS depending on your needs and certificate restrictions.

## <a id="protocol_support"></a> Protocol support

The Gorouter supports HTTP/HTTPS requests only.

For more information about features supported by the Gorouter, see [HTTP Routing](../concepts/http-routing.html).

To secure non-HTTP traffic over TCP routing, terminate TLS at your load balancer or at the app. For more information, see [Enabling TCP Routing](enabling-tcp-routing.html).

## <a id="ssl_options"></a> TLS termination options for HTTP routing

There are several options for terminating TLS for HTTP traffic. You can stop TLS at the Gorouter, your load balancer, or both.

There are two TLS termination options to choose from for your deployment:

* [Gorouter establishes a TLS connection with the app's sidecar Envoy](#gorouter-tls-envoy)

* [Gorouter establishes a mTLS connection with the app's sidecar Envoy](#gorouter-mtls-envoy)


## <a id="certtypes"></a> Certificate requirements

The following requirements apply to the certificates you use to secure traffic into <%= vars.app_runtime_abbr %>:

* You must obtain at least one TLS certificate for your environment.
  * In a production environment, use a signed TLS certificate (trusted) from a known certificate authority (CA).
  * In a development or testing environment, you can use a trusted CA certificate or a self-signed certificate. You can generate a self-signed certificate with `openssl` or a similar tool.
  <%= vars.ssl_cert_ert %>

* Certificates used in <%= vars.app_runtime_abbr %> must be encoded in the PEM format.

* The Gorouter supports mutual TLS, and validates a client provided certificate chain against its CA certificates if one is provided in the TLS handshake, but does not require it. Depending on whether you choose to terminate at both the load balancer and the Gorouter, or at the Gorouter alone, the client certificate can be that of the load balancer or of the originating client.

* The certificate on the Gorouter must be associated with the correct host name so that HTTPS can validate the request.

* If wildcard certificates are not supported for some or all of your domains, then configure termination requests at the load balancer only. In this type of deployment, the load balancer passes unencrypted traffic to the Gorouter. As a result, you avoid having to reissue and reinstall certificates on the Gorouter for every app or UAA security zone.

* Extended Validation (EV) certificates support multiple host names, like SAN, but do not support wildcards. As the Gorouter has not been tested with EV certificates, if EV certificates are required, then terminate TLS at the load balancer only.

* Given the dynamic and multi-tenant nature of <%= vars.app_runtime_abbr %>, <%= vars.company_name %> highly recommends using wildcard domains to avoid the need for adding an additional certificate for each app.

* To support TLS v1.3, ensure that you use certificates generated with a key larger than 512 bits.

## <a id="multcerts"></a> Multiple certificates

In order to support custom domains on <%= vars.app_runtime_abbr %>, an operator has to configure the Gorouter with a certificate that represents the domain. <%= vars.company_name %> recommends that operators add a new certificate instead of reissuing a single certificate when adding TLS support for an additional domain. Using multiple certificates provides a security benefit in that it prevents clients from discovering all the custom domains of apps running on a <%= vars.app_runtime_abbr %> platform.

The Gorouter supports SNI and can be configured with multiple certificates, each which can optionally have wildcard and alternative names. The Gorouter uses SNI to determine the correct certificate to present in a TLS handshake. It requires clients to support the SNI protocol by sending a server name outside the encrypted request payload. For clients that do not support SNI, the Gorouter presents a default certificate. The default is the first certificate keypair in the Gorouter's configuration.

The Gorouter decides which certificate to provide in the TLS handshake as follows:

* If a client provides an SNI header with a ServerName that matches to a configured certificate keypair, the Gorouter returns the matching certificate.

* If a client provides an SNI header with a ServerName that does not match a configured certificate keypair, the Gorouter returns the default certificate.

The first certificate keypair listed is used as the default.

The Gorouter supports both RSA and ECDSA certificates in PEM encoding. In the case that a certificate chain is required, the order should be as follows: primary certificate, intermediate certificate, then root certificate.

### <a id="how-to-config-mult-certs"></a> How to configure multiple certificate keypairs

<%= vars.multiple_certs_gorouter %>

<% if vars.platform_code == 'CF' %>
<%= partial 'ssl_multicerts_gorouter' %>
<% else %>
<% end %>

## <a id="ciphers"></a> TLS cipher suite support

Some <%= vars.app_runtime_abbr %> components like the Gorouter support additional TLS cipher suites to accommodate older clients. As a security best practice, only configure the TLS cipher suites that you need for your deployment.

### <a id="default"></a> Default Gorouter cipher suites

By default, the Gorouter supports the following TLS cipher suites:

| TLS Version | RFC | OpenSSL |
| ----------- | --- | ------- |
| 1.2 | TLS\_ECDHE\_RSA\_WITH\_AES\_128\_GCM\_SHA256 | ECDHE-RSA-AES128-GCM-SHA256 |
| 1.2 | TLS\_ECDHE\_RSA\_WITH\_AES\_256\_GCM\_SHA384 | ECDHE-RSA-AES256-GCM-SHA384 |
| 1.3 | TLS\_AES\_128\_GCM\_SHA256 | TLS13-AES-128-GCM-SHA256 |
| 1.3 | TLS\_AES\_256\_GCM\_SHA384 | TLS13-AES-256-GCM-SHA384 |
| 1.3 | TLS\_CHACHA20\_POLY1305\_SHA256 | TLS13-CHACHA20-POLY1305-SHA256 |

<%= vars.cipher_suites %>

### <a id="aws_elbs"></a> TLS cipher suite support by AWS load balancers

AWS Classic Load Balancers (formerly referred to as ELBs) support configuration of cipher suites for front end connections with clients only. When configuring Classic Load Balancers to forward requests to Gorouters over TLS, oyou might encounter a `Cipher Suite Mismatch` error. This is because the cipher suites supported by Classic Load Balancers for TLS handshakes with back ends (Gorouters in this case) are hardcoded, undocumented, and do not support the Gorouter default cipher suites.

You can configure TLS termination in one of the following ways:

* Configure Classic Load Balancer listeners in TCP mode. This allows TCP connections from clients to pass through the Classic Load Balancer to Gorouters on port 443. With this configuration, Gorouters are the first point of TLS termination.

* If you require TLS termination at an AWS load balancer in addition to terminating at the Gorouter, use [AWS Application Load Balancers (ALBs)](http://docs.aws.amazon.com/elasticloadbalancing/latest/application/introduction.html) that support the Gorouter default cipher suites.

### <a id="tls_1.3"></a> TLS v1.3

You cannot configure cipher suites for TLS v1.3. Gorouter only supports the defaults listed in [Default Gorouter Cipher Suites](#default).

To support TLS v1.3, ensure the Gorouter is configured with certificates generated with a key larger than 512 bits.

### <a id="tls_1.2"></a> TLS v1.2

The following cipher suites are optionally supported for TLS v1.2 only:

| RFC | OpenSSL |
| --- | ------- |
| TLS\_RSA\_WITH\_AES\_128\_GCM\_SHA256 | AES128-GCM-SHA256 |
| TLS\_RSA\_WITH\_AES\_256\_GCM\_SHA384 | AES256-GCM-SHA384 |
| TLS\_ECDHE\_ECDSA\_WITH\_RC4\_128\_SHA | ECDHE-ECDSA-RC4-SHA |
| TLS\_ECDHE\_ECDSA\_WITH\_AES\_128\_CBC\_SHA | ECDHE-ECDSA-AES128-SHA |
| TLS\_ECDHE\_ECDSA\_WITH\_AES\_256\_CBC\_SHA | ECDHE-ECDSA-AES256-SHA |
| TLS\_ECDHE\_RSA\_WITH\_RC4\_128\_SHA | ECDHE-RSA-RC4-SHA |
| TLS\_ECDHE\_RSA\_WITH\_3DES\_EDE\_CBC\_SHA | ECDHE-RSA-DES-CBC3-SHA |
| TLS\_ECDHE\_RSA\_WITH\_AES\_128\_CBC\_SHA | ECDHE-RSA-AES128-SHA |
| TLS\_ECDHE\_RSA\_WITH\_AES\_256\_CBC\_SHA | ECDHE-RSA-AES256-SHA |
| TLS\_ECDHE\_RSA\_WITH\_AES\_128\_GCM\_SHA256 | ECDHE-RSA-AES128-GCM-SHA256 |
| TLS\_ECDHE\_ECDSA\_WITH\_AES\_128\_GCM\_SHA256 | ECDHE-ECDSA-AES128-GCM-SHA256 |
| TLS\_ECDHE\_RSA\_WITH\_AES\_256\_GCM\_SHA384 | ECDHE-RSA-AES256-GCM-SHA384 |
| TLS\_ECDHE\_ECDSA\_WITH\_AES\_256\_GCM\_SHA384 | ECDHE-ECDSA-AES256-GCM-SHA384 |
| TLS\_RSA\_WITH\_AES\_128\_CBC\_SHA256 | AES128-SHA256 |
| TLS\_ECDHE\_ECDSA\_WITH\_AES\_128\_CBC\_SHA256 | ECDHE-ECDSA-AES128-SHA256 |
| TLS\_ECDHE\_RSA\_WITH\_AES\_128\_CBC\_SHA256 | ECDHE-RSA-AES128-SHA256 |
| TLS\_ECDHE\_RSA\_WITH\_CHACHA20\_POLY1305 | ECDHE-RSA-CHACHA20-POLY1305 |
| TLS\_ECDHE\_ECDSA\_WITH\_CHACHA20\_POLY1305 | ECDHE-ECDSA-CHACHA20-POLY1305 |

### <a id="tls_10_11"></a> TLS v1.0 and v1.1

The following cipher suites are optionally supported for TLS v1.0 and TLS v1.1 only:

| RFC | OpenSSL |
| --- | ------- |
| TLS\_RSA\_WITH\_RC4\_128\_SHA | RC4-SHA |
| TLS\_RSA\_WITH\_3DES\_EDE\_CBC\_SHA | DES-CBC3-SHA |
| TLS\_RSA\_WITH\_AES\_128\_CBC\_SHA | AES128-SHA |
| TLS\_RSA\_WITH\_AES\_256\_CBC\_SHA | AES256-SHA |

<%= vars.cipher_suites %>

For more information about supported ciphers, see [Golang Constants](https://github.com/golang/go/blob/release-branch.go1.7/src/crypto/tls/cipher_suites.go#L269-L285) in the Golang repository on GitHub and [Ciphers](https://www.openssl.org/docs/man1.1.1/man1/ciphers.html) in the OpenSSL documentation.

<p class="note">
<span class="note__title">Note</span>
ECDSA ciphers require a certificate and key for DSA, as opposed to RSA.</p>

## <a id="gorouter_mutual_auth"></a> Mutual authentication with clients

The Gorouter supports validation of client certificates in TLS handshakes with clients, also known as mutual authentication. Operators can choose whether the Gorouter requests client certificates and when requesting certificates, whether or not to require them.

By default, the Gorouter requests but does not require client certificates in TLS handshakes.

## <a id="config-gorouter-envoy"></a> Configuring traffic using Gorouter and Envoy

In the general case, the process goes as follows. The specific ports and addresses refer to the example in the graphic.

![alt-text="TLS to the container using Envoy."](./images/TLS-via-envoy.png)

1. The app process listens on port 8080 inside its container.

1. Envoy listens on port 8443 inside the container, terminates TLS with the instance credentials that contain the instance ID a7c, and forwards that traffic to port 8080.

1. The Diego cell forwards traffic from port 61443 on the host to container port 8443.

1.The Diego cell registers its 10.0.0.5 IP and the 61443 host port with the router as a TLS backend for the pivotal.io domain, along with the instance ID a7c.

1. The router receives an HTTP request for example.com.

1. The router connects via TLS to the 10.0.0.5:61443 address, verifies the a7c instance ID, and only then forwards the request.

1. The Diego cell forwards the request payload to Envoy, which in turn forwards it to the app itself for processing.

If the router connects to the wrong app instance because of a route registration that is out of date, its TLS handshake fails, and it backs out and tries a different instance. As a result, the routers also no longer need to drop out-of-date TLS registrations so aggressively. The routers can maintain app availability during extended failures of the route-registration system.

What about when the instance certificates expire? Because the Diego cell already knows it has issued new credentials, it also uses Envoy's dynamic configuration capabilities to update the credentials. On subsequent connections, Envoy uses the new set of credentials for TLS termination without any manual intervention.

### <a id="gorouter-tls-envoy"></a> Gorouter establishes a TLS connection with the app's sidecar Envoy



### <a id="gorouter-mtls-envoy"></a> Gorouter establishes a mTLS connection with the app's sidecar Envoy


