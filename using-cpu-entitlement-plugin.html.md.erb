---
title: Using the CPU entitlement plugin
owner: CLI
---

This topic describes how <%= vars.app_runtime_first %> admins can enable the CPU entitlement plugin to help them manage their CPU resources.

## <a id='cpu-entitlement'></a> CPU Entitlement

If you wish to see an overview of the topic, please see the following video: [CPU Entitlements in Cloud Foundry](https://www.youtube.com/watch?v=vV87xmxKLeA)

CPU entitlement describes the percentage of host CPU a particular application instance is ‘entitled’ to use. Apps will have a CPU performance of 100% when They are using exactly the CPU they are entitled. Apps will have a CPU performance of less than 100% when their usage is less than their entitlement and greater than 100% when they are above their entitlement.

The amount of CPU an application is entitled to is set proportionally to the amount of memory that the application has. For example, an application with access to 256MB of memory on a 512MB machine has access to half of the memory on the machine and is also entitled to half of the CPU of that machine. 

The exact mapping from memory to CPU is determined by the platform operator through a bosh release property on the garden release called [experimental_cpu_entitlement_per_share_in_percent](https://github.com/cloudfoundry/garden-runc-release/blob/9d9826d08b72c0d8b7a7d968b1311047039be08c/jobs/garden/spec#L165-L167).

Entitlement is adjusted when [cpu-entitlement-per-share](https://github.com/cloudfoundry/garden-runc-release/blob/9d9826d08b72c0d8b7a7d968b1311047039be08c/jobs/garden/spec#L165-L167) is modified in the garden config. When a container is throttled, we would expect it to be assigned a share matching its 100% entitlement (rather than currently where the weighting is just based on its weight). This is 100% entitlement when cpu-entitlement-per-share is not modified, but not if the value is modified. 
For example, set cpu-entitlement-per-share to half the default value for the cell, and successfully throttled apps will show 200% current entitlement usage.

The equation used to calculate CPU entitlement is:
entitlement = bundle.Resources.CPU.Shares * cpuEntitlementPerShare * containerAgeNanos / 100.0

## <a id='cpu-entitlement'></a> CPU Entitlement plugin

The metric `AbsoluteCPUEntitlement` shows the amount of CPU usage relative to your entitlement. 

To see app instance `AbsoluteCPUEntitlement` metrics from the command line:

1. Install the CPU Entitlement Plugin from [cpu-entitlement-plugin](https://github.com/cloudfoundry/cpu-entitlement-plugin) in GitHub. 

2. Enable the CPU Entitlement plugin by setting the value for the field [experimental_cpu_throttling](https://github.com/cloudfoundry/garden-runc-release/blob/9d9826d08b72c0d8b7a7d968b1311047039be08c/jobs/garden/spec#L225-L227) to true by using this [operation](https://github.com/cloudfoundry/cf-deployment/blob/main/operations/enable-cpu-throttling.yml#L4)

3. Run the command `cf cpu-entitlement APP-NAME`.

This plugin allows Cloud Foundry application developers to make better decisions about scaling applications and initial resource allocation of applications.

## <a id='cpu-entitlement'></a> Spare CPU resources

Imagine there are 3 cores on the Diego cell to which your application is deployed. That results in 300% CPU that will be distributed between all the applications on the cell, and this is the percentage that the `cf app` command displays. So the metrics depend on factors like the capacity of the Diego cell and the total number of applications on it that are not visible to the user, which makes it hard for users and operators to balance CPU resources.

An app can expect always to be able to get 100% of its CPU entitlement no matter what other applications are on the cell. If there are spare resources on the machine you will be allowed to consume over 100% CPU.

Let’s see how the spare resources are distributed on the Diego cell. Assume your well-behaved application that consumes less than its entitlement most of the time. Since your apps are behaving so well, when you need CPU resources over your entitlement, you should get the maximum amount from the spare CPU you require, but without the CPU entitlement feature free depends on your neighbors (the apps running on the same Diego cell as you are). If the other apps constantly use high CPU, they restrict other apps like yours to use more CPU when needed occasionally. Even though the other apps on the same Diego cell usually use way more CPU than they are entitled to when your app needs extra CPU the spare capacity is being distributed evenly between all the other apps and you. This means you will never be able to spike over a certain amount of CPU. In order to provide the bandwidth occasionally, operators may overprovision resources for Diego cells.

## <a id="cpu-throttling"></a> Throttling

Current versions of Cloud Foundry allow applications to use more CPU than they are entitled to if CPU time is available at that moment, regardless of how the application has behaved in the past. This behavior will change in the future; applications will still be allowed to temporarily exceed their entitlement, but preference will be given to those applications that have been using less than their entitlement over a rolling window of time. Applications will never be forced below their entitlement.

When using the `cf cpu-entitlement` command you see 2 values - average and current usage. The average usage is used to split the application into 2 groups - good and bad. Good applications are the ones that have their average CPU usage below 100% and the bad ones have it over 100%.

Both good and bad application always get their entitlement. If you have enabled the CPU Entitlement plugin, the difference is in how the spare CPU gets distributed between them. All the spare CPU will be given to the good application that needs it and the bad apps will get throttled to only what they are entitled to.

If the CPU spike of a good app is for a long period of time then it will eventually become a bad app and therefore will be throttled to 100% if a different good app needs the CPU. This way resources get distributed more fairly between applications.
